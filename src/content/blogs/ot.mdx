---
title: OT 算法以及 Univer 的协同编辑设计
---

> 这篇博客是 Univer 团队内部分享整理而成。在 Univer 我们经常对有趣的技术问题进行分享和讨论，如果你喜欢这篇博客的内容，不妨考虑[加入我们](mailto:huwenzhao@univer.ai)。

Univer 作为一个企业数据协同工具，我们的目标之一是让用户可以在任何地方、任何时间、任何设备上进行协同编辑。在这个过程中，我们遇到了很多有趣的技术问题，其中最有挑战性的就是 OT 算法的设计。本文将介绍 OT 算法的基本原理，以及 Univer 的协同编辑模块的设计。目前社区里有关 OT 算法的资料很多，但是大多数仅简单介绍了操作转换的概念，对于如何调度操作转换，特别是为什么需要做这些调度，以及如何处理生产环境中的诸多情况则没有做太多讲解。这篇文章尝试把前面这些问题都介绍清楚，如有错误之处请在讨论区指出。

---

## 问题的提出：为什么我们需要一个协同编辑算法？

什么是协同编辑？如果你用过 Google Doc、腾讯文档、飞书文档这样的工具，应该会对协同编辑是什么有概念：多个用户可以同时编辑同一个文档，而且他们可以看到彼此的编辑结果，而且结果大体上是符合这些用户的预期的。我们拿电子表格做一个简单的例子：

用户 A 和用户 B 同时编辑一个表格，A 想要在 C2 单元格插入文本，B 想要在 B 列之前插入一列，两个人编辑完成之后，我们想要看到的结果是：在 A 和 B 的显示屏上，都是 B 列前插入了一列，且在 D2 单元格插入了那段文本。

我们来尝试给协同编辑下一个正式的定义：

如果**编辑者**在**同一文档**的**多个副本**上并发进行编辑（这里并发编辑的意思是：在编辑时，一个副本并没有完全同步了其他副本的所有编辑），我们需要提出一种方法，保证在经过一段时间后：

- **各个副本的内容最终一致**，即最终一致性
- **最终内容符合用户的预期**，即意图保持

其中第一点要求是强保证的。第二点要求尽力保证，即我们不能保证结果一定符合用户的预期（另外用户预期是怎样的，也并不一定存在标准答案），但是我们应该尽可能保证结果符合大多数人的直觉。

实际上，除了最终一致性和意图保持两点要求外，还有另外一点要求：

- **用户的编辑总是要先在本地生效**

接下来我们来看看 OT 是怎么满足这些要求的。

拓展思考：协同编辑问题是一种特殊的分布式数据同步问题 [CAP 定理 - 维基百科，自由的百科全书 (wikipedia.org)](https://zh.m.wikipedia.org/wiki/CAP%E5%AE%9A%E7%90%86) - 保证可用性（用户永远可以编辑本地的副本），分区容忍性（用户的副本可以存在不一致），牺牲强一致性，提供最终一致性（即所有的编辑都已经广播到了所有的副本的时候） AP without C

## OT 的解决方案

### 操作的定义

首先我们给出**操作**的定义，将用户的编辑行为做如下抽象：

1. 操作有这么几个字段：操作的类型（或者称名称、ID，总而言之指的就是何种操作），操作的坐标，操作的参数（因操作的类型而定）
2. 操作的分类有语义化特征，即操作有用户能够感知的语义，例如插入文字、设置属性、删除区域等等
3. 操作的分类有原子化特征，即操作不能再被分解成其他类型的操作

定义了操作之后，用户编辑文档的行为都可以被操作所表示，执行编辑的行为即是在某个副本上应用操作的行为。

### 操作的顺序和版本号

很好理解：同样的操作，以不同的顺序应用在同一副本上，会得到不同的结果。因此需要定义操作的顺序，我们这里引入版本号的概念。

定义初始（未应用任何操作的副本）版本号为 1，应用一个操作之后，副本的版本号加 1 为，此时应用的这个操作的版本号就为 2，或者说，这个操作的 `revision` 属性为 `2`，这样，我们就可以通过版本号来定义操作的顺序了。另外，如果一个操作发生时，发生操作的这个副本的版本号为 123，那么就说这个操作的 `baseRevision` 为 `123`。这样我们也可以用 `baseRevision` 来定义并发的操作，即两个操作拥有相同的 `baseRevision`。

注意，一个操作的 `baseRevision` 为 `x` 并不意味着它的 `revision` 一定为 `x + 1`，这一点我们下一小节就来介绍。

### 协调服务器

现在的问题是，当多个副本同时发生操作时（或者说有多个相同 `baseRevision` 的操作时），我们如何给这些操作分配版本号呢？

这里我们引入一个协调服务器的概念，这个服务器将会给每个操作分配一个版本号，即给它们的 `revision` 属性赋值，通过服务端的仲裁，我们能保证所有的 `revision` 是全局唯一且自增的。

我们举一个例子来说明协调服务器的作用，为了方便后续介绍操作转换的必要性，这里我们假设客户端发生的操作在被服务器分配版本号之前不会在本地应用。

我们假设有 A B C 三个副本都处于 12 版本，此时它们都发生了一个操作，这三个操作的 `baseRevision` 都为 `12`，我们将这三个操作分别命名为 `a`、`b`、`c`，并且假设它们的 `revision` 属性都为 `0`，即还没有被服务器分配版本号。此时，A B C 三个副本都向服务器发送了这三个操作，服务器收到了这三个操作，将它们的 `revision` 属性分别赋值为 `13`、`14`、`15`，并将它们返回给 A B C 三个副本。这三个副本按照 `revision` 的顺序应用这三个操作，此时 A B C 三个副本的版本号都为 `15`，且它们的内容都是一致的。

小结一下：

- 服务端来决定所有操作的应用顺序
- 因为多个副本以相同的顺序应用一批操作，那么副本的内容也完全一致，所以现在的协同方案已经满足了强最终一致性

但现在模型有两个很显然的问题：

第一个问题：客户端发生操作时，没有在本地立即应用，而是要等待服务端排序后才能应用，不满足 用户的编辑总是要先在本地生效 这一条件

第二个问题：不能保证结果符合用户的预期，以开头的例子为例

> 一个简单的例子：用户 A 和用户 B 同时编辑一个表格，A 想要在 C2 单元格插入文本，B 想要在 B 列之前插入一列，两个人编辑完成之后，我们需要在 B 列前插入一列，且在 D2 单元格插入那段文本

如果 A 的操作的 revision 小于 B 操作的 revision，那么结果是符合预期的，但如果 B 操作的 revision 小于 A 操作的 revision，那么结果就不符合预期了。

要解决这两个问题，我们就要引入对操作的转换（Transform）。

### 操作转换

我们细化一下上面假设的三个操作 `a`、`b`、`c`：

- `a` 是在 C2 单元格插入文本
- `b` 是在 B 列之前插入一列
- `c` 是在 A1 单元格设置样式

A B C 三个副本先将这三个操作分别应用再本地，然后将这三个操作发送给服务器，等待服务端发送对三个操作的 ACK 事件。

**处理 `a`**

我们假设服务器永远按照 A B C 副本的顺序来优先处理它们发送过来的操作，此时 `a` 的 `baseRev` 为 `12` 和服务端最后一个操作的 `revision` 一致，所以这个操作可以直接应用在服务端持有的副本上。服务端应用这个操作之后，将这个 `a` 的 `revision` 属性赋值为 `13`，向 A 发送一个 ACK 事件表明该操作已经被服务端接受，并向 B C 广播这个操作 `a`。

A 收到 ACK 之后，将本地版本号自增为 `13`。

B 收到 `a` 之后，发现 `a` 的 `revision` 为 `13`，而 B 的版本号为 `12`，所以 B 应该应用这个操作，但是由于 B 已经先应用的自己的操作 `b`，因此不能直接应用这个操作，B 必须计算 **“在 b 已经已经应用”的前提下，该如何转换 a 得到 a'，转换 b 得到 b'，才能使得应用 ab' 和应用 ba' 的结果一致？** ，这就是操作转换。

> 补充说明：当然有可能存在 `revision` 不是本地版本号加一的情况，如果 `revision` 低于自己的版本号加一，那么直接丢弃即可，如果高于自己的版本号加一，说明本地副本 miss 了一些操作，需要去服务器端补拉这些操作并做操作转换

这里可以得到转换（Transform）的非形式化定义：

**Transform 算法的非形式化定义：假设 a b 是基于相同版本，在不同副本上并发的两个操作，Transform 所做的事情是，在假设 a b 分别已经在各自的副本中应用的情况下，调整 a b 操作得到 a' b'，使得 ab' ba' 的应用结果一致。**

B 在转换得到 `b'` 之后，虽不需要应用到本地，但是需要将 `b'` 的 `baseRevision` 属性设置为 `13`，这是为什么？因为 `b'` 是在 `a` 之后发生的，而 `a` 已经是被服务端所确认的 `13` 号操作，所以 `b'` 的 `baseRevision` 也应该改为 `13`。

C 对于 `a` 的处理和 B 类似，不再赘述。

**处理 `b`**

首先 b `baseRevision` 是 12，而此时服务端副本的版本号已经是 `13`，因此服务端收到此操作之后，需要对 a b 进行 transform 得到 b' 再将 b' 应用在服务端的副本上，并给 b' 设置 `revision` 为 `14`。然后向 B 发送 ACK 事件，向 A C 广播 `b`。

注意，这里为什么广播的是 b' 而不是 b？

- 对于 A 来说，此时它的版本号已经升到 `13`，直接应用 `b'` 就可以直接到 `14`，其实你可以注意到 A 和服务端的副本应用的操作实际是完全一致的
- 对于 C 来说，它之前收到 `a` 的时候，已经对 `a` 进行了一次 transform 得到`c'`，`c'` 的 `baseRevision` 为 `13`，如果再对 `c'` 和 `b` 进行 transform，由于它们的 `baseRevision` 不一致，不能直接 transform，而要先对 `b` `a`进行一次 transform 重新得到 `b'`;，不如直接用服务端 transform 好的 `b'`。

**处理 `c`**

对于 `c` 的处理和 `b` 类似，不再赘述，大家可以自行推演。

小结一下：

- 通过引入操作转换，使得操作可以先在本地生效

### 操作转换改变了什么

接下来让我们关注一下操作转换改变了什么。

TODO

## 真实场景中需要考虑的问题

以上就是 OT 算法的基本原理，但是在实际的生产环境中，我们还需要考虑很多其他的问题，这些问题都是在我们的实践中会遇到的。

### 操作的合并和压缩

### 协同光标

### Undo Redo

### 所有的网络请求都默认不可靠

### 离线编辑

### 冲突处理

### 历史记录

## Univer 的协同编辑模块设计

## 附：为什么我们不用 CRDT？

出于以下两点考虑，我们选择了 OT 算法而非 CRDT 作为解决方案：

1. Univer 主要用在企业办公领域，CRDT 的本地优先、无需协调服务器的特性在 Univer 的应用场景中并不是特别重要；而 OT 的协调服务器能够更方便地让我们处理编辑权限控制，及确定用户变更在历史记录中的顺序；
2. 目前尚没有在电子表格领域大规模使用 CRDT 的实践，我们不确定 CRDT 能否解决电子表格中复杂的意图保持问题，也不确定在超大电子表格文档中 metadata 会不会导致过高的存储和内存占用。相反，由于 OT 是 case by case 地解决冲突的，因此让我们能够手动解决意图保持问题，数据结构也相对简单，更加可靠。

---

作者：[Wenzhao Hu](https://github.com/wzhudev)，Univer 团队架构师。负责协同编辑模块的设计和研发。
